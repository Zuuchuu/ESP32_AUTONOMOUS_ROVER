# Overview  
The ESP32 Autonomous Rover project delivers a small, WiFi-enabled robot rover based on the ESP32 30-pin DevKit, capable of autonomous waypoint navigation. It is controlled via a Windows desktop application built with Python (PyQt5) and features an interactive map (Leaflet.js) for mission planning, real-time telemetry, and manual control. The system is designed for engineers, students, and hobbyists in robotics and embedded systems.

# Core Features  
- **Autonomous Waypoint Navigation**: Rover receives up to 10 waypoints and autonomously navigates using GPS and IMU data, with PID and cross-track error correction.
- **Real-Time Telemetry**: Rover streams position, heading, IMU data, temperature, and WiFi status to the desktop app for live monitoring.
- **Interactive Mission Planning**: Desktop app provides a GUI with an embedded map for selecting waypoints, manual entry, and mission control (start/stop, speed adjustment).
- **Robust Communication**: Uses TCP sockets and JSON for reliable, extensible data exchange between app and rover.
- **Manual Control & Status**: App allows manual waypoint entry, connection management, and displays connection status.
- **Error Handling**: Both firmware and app include validation, error messages, and reconnection logic.

# User Experience  
- **Personas**: Robotics engineers, students, hobbyists.
- **Key Flows**:
  - User powers on rover, which connects to WiFi and starts TCP server.
  - User launches app, enters rover IP, connects, and plans mission via map or manual entry.
  - User sends waypoints and commands (start, stop, speed) to rover.
  - Rover navigates autonomously, sending telemetry to app for real-time display.
  - User monitors progress, adjusts speed, or stops mission as needed.
- **UI/UX**:
  - Left: Map for waypoint selection and rover tracking.
  - Right: Controls for connection, waypoint management, rover control, and telemetry/status display.
  - Clear error messages and status indicators for connectivity and input validation.

# Technical Architecture  
- **‚úÖ Rover (ESP32)**: **COMPLETED**
  - FreeRTOS-based, modular tasks: WiFi (TCP server), GPS (UART), IMU (I2C), Navigation (PID, XTE), Telemetry.
  - Shared data (position, heading, waypoints) protected by mutexes.
  - Receives waypoints/commands as JSON, sends telemetry as JSON.
  - Hardware: ESP32, N20 DC motors, TB6612FNG driver, GY-87 IMU, u-blox M10 GPS.
  - **Status**: All firmware components implemented, compiled successfully, ready for testing.
- **‚è≥ Control Station App**: **IN PROGRESS**
  - Python 3.8+, PyQt5 GUI, QWebEngineView for map (Leaflet.js in map.html).
  - TCP client for communication, QThread for telemetry reception.
  - GUI: Map panel, connection controls, waypoint table, manual entry, rover control (start/stop/speed), telemetry/status display.
  - Error handling for connection, input validation, and map loading.

# Development Roadmap  
- **‚úÖ ESP32 Rover Firmware - COMPLETED**:
  - ‚úÖ WiFi Task: Connect to WiFi, start TCP server on port 80, accept JSON waypoints/commands
  - ‚úÖ GPS Task: Read GPS data via UART, parse NMEA sentences, update current position
  - ‚úÖ IMU Task: Read heading from GY-87 IMU, update current heading, support calibration
  - ‚úÖ Navigation Task: Calculate distance to waypoints, use PID and XTE for steering, control motors
  - ‚úÖ Telemetry Task: Send JSON telemetry (position, heading, IMU data, temperature, WiFi strength)
  - ‚úÖ Shared Data & Mutexes: Thread-safe data structures with FreeRTOS mutexes
  - ‚úÖ Error Handling: Comprehensive error checking and Serial output

- **‚è≥ Control Station App (Python, PyQt5) - IN PROGRESS**:
  - GUI Layout: Left panel with QWebEngineView (Leaflet.js map, up to 10 waypoints), right panel with controls (IP input, connect button), waypoint table, manual entry, start/stop, speed slider, telemetry/status display.
  - TCP Client: Connect to rover's IP/port 80, send waypoints as JSON, send commands (start, stop, set_speed), receive and parse JSON telemetry.
  - Waypoint Management: Add waypoints by clicking map or manual entry, display in table, clear waypoints, validate latitude/longitude input.
  - Rover Control: Start/stop navigation, adjust speed (0-100%).
  - Telemetry Display: Show position, heading, IMU data, temperature, WiFi strength, update rover marker on map.
  - Threading: Use QThread for telemetry reception to keep GUI responsive.
  - Error Handling: Show connection errors (QMessageBox), validate user input, handle map loading errors.

  **End-to-End Test**
  - Power on rover, connect to WiFi, note IP.
  - Launch app, connect to rover.
  - Add waypoints (map/manual), send to rover.
  - Start navigation, observe rover movement and telemetry updates.
  - Adjust speed, stop mission, clear waypoints.
  - Simulate connection loss, invalid input, and observe error handling.

- **Future Enhancements**:
  - Offline map support in app.
  - Advanced mission planning (e.g., path editing, mission save/load).
  - Enhanced telemetry (battery, diagnostics).
  - Multi-rover support.
  - Web-based or cross-platform app.

# Logical Dependency Chain
- ‚úÖ Foundation: ESP32 hardware setup, sensor/driver wiring, and initial firmware (WiFi, GPS, IMU tasks).
- ‚úÖ Next: Implement navigation logic (PID, XTE), mutexes, and telemetry.
- ‚è≥ In parallel: Develop desktop app GUI, map integration, and TCP client.
- ‚è≥ Integrate: Test communication, send/receive JSON, validate end-to-end flow.
- ‚è≥ Polish: Add error handling, UI improvements, and documentation.
- üìã Enhance: Add advanced features and optimizations as needed.

# Current Project Status
- **‚úÖ ESP32 Rover**: 100% Complete - All tasks implemented, compiled successfully, ready for testing
- **‚è≥ Control Station App**: 0% Complete - Ready to start implementation
- **‚è≥ Integration**: Ready for end-to-end testing once desktop app is complete

# Risks and Mitigations  
- **Network Reliability**: WiFi dropouts or cross-network issues. Mitigation: Reconnection logic, use of tools like ngrok for remote access.
- **Sensor Accuracy**: GPS/IMU drift or noise. Mitigation: Calibration routines, sensor fusion (future).
- **Resource Constraints**: ESP32 memory/CPU limits. Mitigation: Modular code, optimize task stack sizes.
- **User Error**: Invalid waypoint input or connection issues. Mitigation: Input validation, clear error messages.
- **Map Loading**: Internet required for map tiles. Mitigation: Offline map support (future).

# Appendix  
- **Reference Code**: See ESP32_Rover.markdown and ControlStationApp.markdown for code snippets and setup.
- **Technical Specs**: Pin mappings, task stack sizes, JSON message formats, and UI layout details.
- **Testing**: Procedures for map, communication, and telemetry validation.